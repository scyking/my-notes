# Redis 缓存策略

标签（空格分隔）： redis

---

[toc]

## 使用缓存策略考虑问题
> 缓存策略取决于数据和数据访问模式，即数据是如何读写的。

- 系统是写多读少的吗？
- 数据是否是只写入一次并被读取多次?
- 返回的数据总是惟一的吗?
- ...

## 常见策略

- `Cache-Aside`
- `Read-Through Cache`
- `Write-Through Cache`
- `Write-Behind`（`Write-Back`）

### `Cache-Aside`
> 应用程序会与缓存和数据源进行通信，应用程序会在命中数据源之前先检查缓存。

- 请求数据过程
1. 应用程序先确定数据是否保留在缓存中；
1. 如果数据在缓存中，也即 Cache hit ，称作“缓存命中”。数据直接从缓存中读取并返回给客户端应用程序；
1. 如果数据不在缓存中，也即 Cache miss，称作“缓存未命中”。应用程序会从数据存储的地方，如 `MySQL` 数据源中读取该数据，并将数据存储在缓存中，然后将其返回给客户端。

- 适用场景
> 适合“读多”的应用场景。

- 优点
1. 可以在一定程度上抵抗缓存故障。如果缓存服务发生故障，系统仍然可以通过直接访问数据库进行操作。
2. 缓存中的数据模型可以与数据库中的数据模型不同。例如，多个查询产生的响应可以存储在某个请求id上。

- 缺点
1. 不能保证数据存储和缓存之间的一致性，需要配合使用其它策略来更新或使缓存无效。（可通过设置TTL解决）
2. 首次请求数据时，总是会导致缓存未命中，这种情况下需要额外的时间来将数据加载到缓存中。（可通过手动触发查询操作来对数据进行“预热”解决）

### `Read-Through Cache`
> 缓存与数据库保持一致。当缓存丢失时，它从数据库加载相应的数据，填充缓存并将其返回给应用程序。

- 适用场景
> 适用于多次请求相同数据的场景。

- 与`Cache-Aside`区别
1. 在`Cache-Aside`中，应用程序负责从数据库中获取数据并填充缓存。在`Read-Through`中，此逻辑通常由库或独立缓存提供程序支持。
1. 与`Cache-Aside`不同，`Read-Through`中的数据模型不能与数据库中的数据模型不同。

### `Write-Through Cache`
> 首先将数据写入缓存，然后写入数据库。缓存与数据库保持一致，写操作总是通过缓存到达主数据库。

- 使用场景
> 一般都配合使用`Read-Through`。

- 适用场景

1. 需要频繁读取相同数据
1. 不能忍受数据丢失（相对`Write-Behind`而言）和数据不一致

### `Write-Behind`（也称`Write-Back`）
> 应用程序将数据写入缓存，缓存会立即确认，并在延迟一段时间后将数据写入数据库。

- 适用场景
> 缓存提高了写性能，对于写工作量大的工作负载非常有用。

- 与`Write-Through`区别
1. `Write-Through`会把数据立即写入数据库中。
2. `Write-Behind`会在一段时间之后（或是被其他方式触发）把数据一起写入数据库，这个异步写操作是`Write-Behind`的最大特点。


