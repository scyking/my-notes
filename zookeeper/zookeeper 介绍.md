# zookeeper 介绍

标签（空格分隔）： zookeeper

---

ZooKeeper是⼀个分布式的,开源的分布式应⽤程序协调服务。


四种类型znode

持久节点(Persistent)：客⼾端与zookeeper服务端断开连接后，该节点仍然存在。
持久有序节点(Persistent_sequential)
在持久节点基础上，由zookeeper给该节点名称进⾏有序编号，如0000001，0000002。
临时节点(Ephemeral)
客⼾端与zookeeper服务端断开连接后，该节点被删除。临时节点下，不存在⼦节点。
临时有序节点(Ephemeral_sequential)
在临时节点基础上，由zookeeper给该节点名称进⾏有序编号，如0000001，0000002。
节点监听(Wacher)
客⼾端2注册监听它关⼼的临时节点SubApp1的变化，当临时节点SubApp1发⽣变化时（如图中被删除的时候），zookeeper会
通知客⼾端2。
该机制是zookeeper实现分布式协调的重要特性。我们可以通过get，exists，getchildren三种⽅式对某个节点进⾏监听。但是
该事件只会通知⼀次。

最简单的数据结构就是数组或链表了。它们被称为线性表，是⼀维的，具有线性关系，即前后顺序，优点是简单，缺点
是功能不够强⼤。
然后就是树了，可以认为它是两维的，左右是兄弟关系，上下是⽗⼦关系，因此具有从属关系。它是⼀个功能与复杂
度兼顾的结构。现实⽣活中的各类组织架构⼤都是树形的。
再复杂的就是图了，它是⽹状结构，可以认为是多维的，由于任何节点都可以连通，因此它表达⼀种多边关系。虽功
能强⼤但也很复杂。现实中的铁路⽹和⼈际关系⽹⼤都是⽹状的。

zookeeper 选择了树作为⾃⼰存储数据的结构

功能：监视节点、通知进程、保持⻓连接，会话延续
1、⽂件系统
2、通知机制

其实⼯作过程是这样的，业务进程启动后与 zookeeper 建⽴连接，然后在 zookeeper ⾥创建临时节点并写⼊⾃⼰
的相关信息。接着通过周期性的⼼跳和 zookeeper 保持住连接。
⼀旦业务进程挂掉，zookeeper 将接受不到⼼跳了，那么在超过⼀定的时间后，zookeeper 将会删除与之对应的临
时节点，表⽰这个业务进程不再可⽤了。

使用场景

- 分布式协调（消息队列）
- 分布式锁
- 元数据/配置信息管理
- HA⾼可⽤性

## 分布式锁

步骤1: 如图，根据zookeeper有序临时节点的特性，每个进程对应连接⼀个有序临时节点（进程1对应节点/znode/00000001，
进程2对应节点/znode/00000002…如此类推）。每个进程监听对应的上⼀个节点的变化。编号最⼩的节点对应的进程获得锁，
可以操作资源。

步骤2: 当进程1完成业务后，删除对应的⼦节点/znode/00000001，释放锁。此时，编号最⼩的锁便获得锁
（即/znode/00000002对应进程）。
重复以上步骤，保证了多个进程获取的是同⼀个锁，且只有⼀个进程能获得锁，就是zookeeper分布式锁的实现原理。


## 服务注册与发现

### 服务注册原理

rpc框架会在zookeeper的注册⽬录下，为每个应⽤创建⼀个持久节点，如order应⽤创建order持久节点，member应⽤创建
member持久节点。
然后在对应的持久节点下，为每个微服务创建⼀个临时节点，记录每个服务的URL等信息。

### 服务动态发现原理

由于服务消费⽅向zookeeper订阅了（监听）服务提供⽅，⼀旦服务提供⽅有变动的时候（增加服务或者减少服
务），zookeeper就会把最新的服务提供⽅列表（member list）推送给服务消费⽅，这就是服务动态发现的原理。


7.zk的命名服务（⽂件系统）
命名服务是指通过指定的名字来获取资源或者服务的地址，利⽤zk创建⼀个全局的路径，即是唯⼀的路径，这个路径就可以作为
⼀个名字，指向集群中的集群，提供的服务的地址，或者⼀个远程的对象等等。

8.zk的配置管理（⽂件系统、通知机制）
程序分布式的部署在不同的机器上，将程序的配置信息放在zk的znode下，当有配置发⽣改变时，也就是znode发⽣变化时，可
以通过改变zk中某个⽬录节点的内容，利⽤watcher通知给各个客⼾端，从⽽更改配置。

9.Zookeeper集群管理（⽂件系统、通知机制）
所谓集群管理⽆在乎两点：是否有机器退出和加⼊、选举master。
对于第⼀点，所有机器约定在⽗⽬录下创建临时⽬录节点，然后监听⽗⽬录节点的⼦节点变化消息。⼀旦有机器挂掉，该机器与
zookeeper的连接断开，其所创建的临时⽬录节点被删除，所有其他机器都收到通知：某个兄弟⽬录被删除，于是，所有⼈都知
道：它上船了。
新机器加⼊也是类似，所有机器收到通知：新兄弟⽬录加⼊，highcount⼜有了，对于第⼆点，我们稍微改变⼀下，所有机器创
建临时顺序编号⽬录节点，每次选取编号最⼩的机器作为master就好。

15.zookeeper是如何保证事务的顺序⼀致性的？
zookeeper采⽤了递增的事务Id来标识，所有的proposal（提议）都在被提出的时候加上了zxid，zxid实际上是⼀个64位的数
字，⾼32位是epoch（时期; 纪元; 世; 新时代）⽤来标识leader是否发⽣改变，如果有新的leader产⽣出来，epoch会⾃增，低
32位⽤来递增计数。当新产⽣proposal的时候，会依据数据库的两阶段过程，⾸先会向其他的server发出事务执⾏请求，如果超
过半数的机器都能执⾏并且能够成功，那么就会开始执⾏。

16.Zookeeper 下 Server⼯作状态
每个Server在⼯作过程中有三种状态：
LOOKING：当前Server不知道leader是谁，正在搜寻
LEADING：当前Server即为选举出来的leader
FOLLOWING：leader已经选举出来，当前Server与之同步

17.zookeeper是如何选取主leader的？
当leader崩溃或者leader失去⼤多数的follower，这时zk进⼊恢复模式，恢复模式需要重新选举出⼀个新的leader，让所有的
Server都恢复到⼀个正确的状态。Zk的选举算法有两种：⼀种是基于basic paxos实现的，另外⼀种是基于fast paxos算法实现
的。系统默认的选举算法为fast paxos。

20.机器中为什么会有leader？
在分布式环境中，有些业务逻辑只需要集群中的某⼀台机器进⾏执⾏，其他的机器可以共享这个结果，这样可以⼤⼤减少重复计
算，提⾼性能，于是就需要进⾏leader选举。

23.zookeeper watch机制
Watch机制官⽅声明：⼀个Watch事件是⼀个⼀次性的触发器，当被设置了Watch的数据发⽣了改变的时候，则服务器将这个改
变发送给设置了Watch的客⼾端，以便通知它们。
Zookeeper机制的特点：
1、⼀次性触发数据发⽣改变时，⼀个watcher event会被发送到client，但是client只会收到⼀次这样的信息。
2、watcher event异步发送watcher的通知事件从server发送到client是异步的，这就存在⼀个问题，不同的客⼾端和服务器之
间通过socket进⾏通信，由于⽹络延迟或其他因素导致客⼾端在不通的时刻监听到事件，由于Zookeeper本⾝提供了ordering
guarantee，即客⼾端监听事件后，才会感知它所监视znode发⽣了变化。所以我们使⽤Zookeeper不能期望能够监控到节点每
次的变化。Zookeeper只能保证最终的⼀致性，⽽⽆法保证强⼀致性。
3、数据监视Zookeeper有数据监视和⼦数据监视getdata() and exists()设置数据监视，getchildren()设置了⼦节点监视。
4、注册watcher getData、exists、getChildren
5、触发watcher create、delete、setData
6、setData()会触发znode上设置的data watch（如果set成功的话）。⼀个成功的create() 操作会触发被创建的znode上的数
据watch，以及其⽗节点上的child watch。⽽⼀个成功的delete()操作将会同时触发⼀个znode的data watch和child
watch（因为这样就没有⼦节点了），同时也会触发其⽗节点的child watch。
7、当⼀个客⼾端连接到⼀个新的服务器上时，watch将会被以任意会话事件触发。当与⼀个服务器失去连接的时候，是⽆法接收
到watch的。⽽当client重新连接时，如果需要的话，所有先前注册过的watch，都会被重新注册。通常这是完全透明的。只有在
⼀个特殊情况下，watch可能会丢失：对于⼀个未创建的znode的exist watch，如果在客⼾端断开连接期间被创建了，并且随后
在客⼾端连接上之前⼜删除了，这种情况下，这个watch事件可能会被丢失。
8、Watch是轻量级的，其实就是本地JVM的Callback，服务器端只是存了是否有设置了Watcher的布尔类型

