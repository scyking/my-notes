# mysql 锁

标签（空格分隔）： mysql

---

[toc]

## 全局锁
> MySQL提供了⼀个加全局读锁的⽅法，命令是 `Flush tables with read lock` (FTWRL)。

### 作用
> 执行全局锁命令后，其他线程的以下语句会被阻塞：

- 数据更新语句（数据的增删改）
- 数据定义语句（包括建表、修改表结构等）
- 更新类事务的提交语句

### 应用场景
> ⼀般会在进⾏ **全库逻辑备份** 的时候使⽤，这样就能确保其他线程不能对该数据库做更新操作。

## 表锁
> MDL(Meta Data Lock)元数据锁。MDL锁⽤来保证只有⼀个线程能对该表进⾏表结构更改。

### MDL写锁
> 当线程对⼀个表进⾏ 表结构更改 操作的时候会加 MDL写锁。

```
lock tables xxx write;
```

### MDL读锁
> 当线程对⼀个表进⾏ `CRUD` 操作的时候会加 MDL读锁。

```
lock tables xxx read;
```

### 备注
> 写锁和读锁，写锁和写锁互斥，读锁之间不互斥
> 如果，在某个线程A中执⾏`lock tables t1 read, t2 write;`这个语句，则其他线程写t1、读写
t2的语句都会被阻塞。同时，线程A在执⾏`unlock tables`之前，也只能执⾏读t1、读写t2的操作。连写t1都不允许，⾃然也不能访问其他表。

## ⾏锁
> 在5.5版本以前 MySQL 的默认存储引擎是 MyISAM，⽽ MyISAM 和 InnoDB 最⼤的区别就是两个事务⾏锁。

### 写锁(排他锁 X锁)
> 允许获得排他锁的事务更新数据，阻⽌其他事务取得相同数据集的共享读锁和排他写锁。也叫做写锁：写锁是排他的，写锁会阻塞其他的写锁和读锁。

### 读锁(共享锁 S锁)
> 允许⼀个事务去读⼀⾏，阻⽌其他事务获得相同数据集的排他锁。也叫做读锁：读锁是共享的，多个客⼾可以同时读取同⼀个资源，但不允许其他客⼾修改。

### 死锁问题
> 如果事务A对⾏100加了写锁，事务B对⾏101加了写锁，此时事务A想要修改⾏101⽽事务B⼜想修改⾏100，这样占有且等待就导致了死锁问题。

## next-key锁
> 为解决 **幻读** 问题，InnoDB使⽤了 **GAP锁(间隙锁)** 配合**⾏锁**形成了`next-key`锁。

### 加锁规则

- 加锁的基本单位是next-key lock 就是⾏锁和GAP锁结合。
- 查找过程中访问到的对象就会加锁。
- 索引上的等值查询，给唯⼀索引加锁的时候，next-key lock退化为⾏锁。
- 索引上的等值查询，向右遍历时且最后⼀个值不满⾜等值条件的时候，next-key lock退化为间隙锁。
- 唯⼀索引上的范围查询会访问到不满⾜条件的第⼀个值为⽌。




