# Redis 缓存异常场景

标签（空格分隔）： redis

---

[toc]

## 缓存穿透

### 描述

> 指缓存和数据库中都没有数据，而用户不断发起请求。
> 这时用户可能是攻击者，攻击会导致数据库压力过大。

### 解决方案

1. 缓存空对象
2. 布隆过滤器（推荐）

#### 缓存空对象

> 当缓存未命中，查询持久层也为空，可以将返回的空对象写到缓存中，这样下次请求该key时直接从缓存中查询返回空对象，请求不会落到持久层数据库。
> 为了避免存储过多空对象，通常会给空对象设置一个过期时间。

- 存在的问题

1. 如果有大量的key穿透，缓存空对象会占用宝贵的内存空间。
1. 空对象的key设置了过期时间，在这段时间可能会存在缓存和持久层数据不一致的场景。

#### 布隆过滤器（BF，Bloom Filter）

> 用来检测集合中是否存在特定的元素。

使用方法（`java`）：

- 添加maven依赖

```
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>20.0</version>
</dependency>
```

- 代码

```
public class BloomFilterDemo {
    public static void main(String[] args) {
        //插入的key为字符串，预计数据量为一百万，并且容错率为0.01
        BloomFilter bloomFilter = BloomFilter.create(Funnels.stringFunnel(Charset.defaultCharset()),
                1000000,0.01);
        bloomFilter.put("sunkang");
        System.out.println(bloomFilter.mightContain("sunkang"));
    }
}
```

## 缓存击穿

### 描述

> 指缓存中没有但数据库有的数据（一般是热点数据，缓存时间到期）。
> 这时由于并发用户特别多，同时读缓存没有读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大。

### 解决方案

1. 设置热点数据永不过期
2. 使用互斥锁排队

## 缓存雪崩

### 描述

> 缓存在同一时间内大量键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。

### 解决方案

1. 互斥锁排队
2. 缓存永不过期、均匀过期
3. 双层缓存策略
    - 主缓存：有效期按照经验值设置，设置为主读取的缓存，主缓存失效后从数据库加载最新值。
    - 备份缓存：有效期长，获取锁失败时读取的缓存，主缓存更新时需要同步更新备份缓存。

## 缓存预热

### 描述

> 系统上线后，将相关的缓存数据直接加载到缓存系统。
> 这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。

### 操作方法

1. 数据量不大时，工程启动的时候进行加载缓存动作。
2. 数据量大时，设置一个定时任务脚本，进行缓存的刷新。
3. 数据量太大时，优先保证热点数据进行提前加载到缓存。

## 缓存降级

> 就是缓存失效或者缓存服务器宕机的情况下，不去访问数据库，直接访问内存部分数据或者直接返回默认数据。