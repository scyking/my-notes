# Redis 持久化

标签（空格分隔）： redis

---

[toc]

## 概念

Redis 的读写都是在内存中，所以它的性能较⾼，但在内存中的数据会随着服务器的重启⽽丢失，为了保证数据不丢失，我们需要将内存中的数据存储到磁盘，以便`Redis`重启时能够从磁盘中恢复原有的数据，⽽整个过程就叫做`Redis`持久化。

## 方式

### RDB（RDB，Redis DataBase）
> 将某一个时刻的内存数据，以二进制的方式写入磁盘；（PS：持久化⽂件 `dump.rdb`）

#### 触发方式
1. 手动触发
    - `save`命令 会使redis主线阻塞，直到持久化完成。
    - `bgsave`命令 会`fork()`一个子进程来持久化，仅创建子进程时有短暂的阻塞。

2. 自动触发
    - `save m n` 在m秒内，如果有n个键发生改变，则自动触发持久化。
    - `flushall`命令 用于清空redis数据库，执行后触发持久化。
    - 主从同步触发 从节点执行全量复制操作时，主节点会执行`bgsave`命令，并将`RDB`文件发送给从节点。

#### 配置说明

1. `save` 参数 触发RDB持久化条件，默认配置如下：
    - `save 900 1`
    - `save 300 10`
    - `save 60 10000`
1. `rdbcompression` 参数 是否开启`RDB`文件压缩，默认开启
1. `rdbchecksum` 参数 是否开启`RDB`文件检查，写入文件和读取文件时检查文件是否有无损坏

#### 过期key处理
> 过期key对RDB没有任何影响

- 从内存数据库持久化数据到RDB文件，会对key进行过期检查，过期则不进入RBD文件
- 从RDB文件恢复数据到内存数据库，会对key进行过期检查，过期则不导入数据库

#### 优点

- 文件内容为二进制数据，占用内存小、更紧凑，更适合作为备份文件；
- 对灾难恢复非常有用，它是一个紧凑的文件，可以更快的传输到远程服务器进行redis服务恢复；
- 通过fork()子进程持久化数据，可以更大程度提高redis的运行速度；
- 与AOF格式的文件相比，RDB文件可以更快的重启；

#### 缺点

- RDB只能保存某个时间间隔的数据，如果中途redis服务被意外终止，则会丢失一段时间的redis数据；
- RDB需经常fork才能使子进程将其持久化在磁盘上。如果数据量很大，fork可能会很耗时，抢占cpu资源，影响redis主进程性能。

### AOF（AOF，Append Only File）
> 记录所有的操作命令，并以文本的形式追加到文本中；

#### 开启AOF持久化

1. 修改配置，将appendonly属性修改为yes
2. 修改appendfsync属性
    - always 表示总是即时将缓冲区内容写入AOF文件当中
    - everysec 表示每隔一秒将缓冲区内容写入AOF文件
    - no 表示将写入文件操作交由操作系统决定

#### COW（写时拷贝）
>Redis ⽀持这样的功能，在不中断前台服务的情况下，可以重写 AOF ⽂件，同样使⽤到了 COW（写时拷⻉）。

- 调⽤ fork()，创建⼀个⼦进程。
- ⼦进程把新的 AOF 写到⼀个临时⽂件⾥，不依赖原来的 AOF ⽂件。
- 主进程持续将新的变动同时写到内存和原来的 AOF ⾥。
- 主进程获取⼦进程重写 AOF 的完成信号，往新 AOF 同步增量变动。
- 使⽤新的 AOF ⽂件替换掉旧的 AOF ⽂件。

#### 过期key处理
> 过期key对AOF没有任何影响

- 从内存数据库持久化数据到AOF文件
    1. 当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）
    2. 当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）
- AOF重写，会先判断key是否过期，已过期的key不会重写到aof文件 

#### 优点
可读性高，适合保存增量数据，数据不易

#### 缺点
文件体积大，恢复
    
### 混合持久化
> RDB作为全量备份，AOF作为增量备份。
> Redis 4.0 之后新增的⽅式，混合持久化是结合了`RDB`和`AOF`的优点，在写⼊的时候，先把当前的数据以`RDB`的形式写⼊⽂件的开头，再将后续的操作命令以`AOF`的格式存⼊⽂件。