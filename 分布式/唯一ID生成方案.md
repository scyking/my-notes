# 唯一ID生成方案

标签（空格分隔）： 分布式

---

[toc]

## 生成ID要求

- 整个系统ID唯⼀
- ID是数字类型，⽽且是趋势递增的
- ID简短，查询效率快

### 递增
> 如：第⼀次⽣成的ID为12，下⼀次⽣成的ID是13，再下⼀次⽣成的ID是14。这个就是⽣成ID递增。

### 趋势递增
> 在⼀段时间内，⽣成的ID是递增的趋势。
> 如：再⼀段时间内⽣成的ID在【0，1000】之间，过段时间⽣成的ID在【1000，2000】之间。但在【0-1000】区间内的时候，ID⽣成有可能第⼀次是12，第⼆次是10，第三次是14。

## UUID

### 优点
- 代码实现简单
- 本机⽣成，没有性能问题
- 因为是全球唯⼀的ID，所以迁移数据容易

### 缺点
- 每次⽣成的ID是⽆序的，⽆法保证趋势递增
- UUID的字符串存储，查询效率慢
- 存储空间⼤
- ID本事⽆业务含义，不可读

### 应⽤场景
- 类似⽣成token令牌的场景
- 不适⽤⼀些要求有趋势递增的ID场景


## MySQL主键⾃增
这个⽅案就是利⽤了MySQL的主键⾃增auto_increment，默认每次ID加1。

### 优点
- 数字化，id递增
- 查询效率⾼
- 具有⼀定的业务可读

### 缺点
- 存在单点问题，如果mysql挂了，就没法⽣成iD了
- 数据库压⼒⼤，⾼并发抗不住


## MySQL多实例主键⾃增
> 这个⽅案就是解决mysql的单点问题，在auto_increment基础上，设置step步⻓。
> 每台的初始值分别为1,2,3...N，步⻓为N（这个案例步⻓为4）

### 优点
- 解决了单点问题

### 缺点
- ⼀旦把步⻓定好后，就⽆法扩容；
- 单个数据库的压⼒⼤，数据库⾃⾝性能⽆法满⾜⾼并发

### 应⽤场景
- 数据不需要扩容的场景


## 雪花（snowflake）算法
> 雪花算法⽣成64位的⼆进制正整数，然后转换成10进制的数。

### 优点
- 每秒能够产⽣409.6万个ID，性能快
- 时间戳在⾼位，⾃增序列在低位，整个ID是趋势递增的，按照时间有序递增
- 灵活度⾼，可以根据业务需求，调整bit位的划分，满⾜不同的需求

### 缺点
- 依赖机器的时钟，如果服务器时钟回拨，会导致重复ID⽣成
- 在分布式场景中，服务器时钟回拨会经常遇到，⼀般存在10ms之间的回拨；此算法是建⽴在毫秒级别的⽣成⽅案，⼀旦回拨，就很有可能存在重复ID。

## Redis⽣成⽅案
> 利⽤redis的incr原⼦性操作⾃增，⼀般算法为：`年份 + 当天距当年第多少天 + 天数 + ⼩时 + redis自增`。

### 优点
- 有序递增，可读性强

### 缺点
- 占⽤带宽，每次要向redis进⾏请求