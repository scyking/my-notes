# java 代码优化

标签（空格分隔）： java

---

[toc]

## 对象相关

### 尽量避免过多过常地创建`Java`对象
> 尽量避免在经常调⽤的⽅法，循环中`new`对象。
> 由于系统不仅要花费时间来创建对象，⽽且还要花时间对这些对象进⾏垃圾回收和处理，在我们可以控制的范围内，最⼤限度地重⽤对象，最好能⽤基本的数据类型或数组来替代对象。

#### 尽量在合适的场合使⽤单例
> 使⽤单例可以减轻加载的负担，缩短加载的时间，提⾼加载的效率。

主要适⽤于以下三个⽅⾯：

1. 控制资源的使⽤，通过线程同步来控制资源的并发访问；
1. 控制实例的产⽣，以达到节约资源的⽬的；
1. 控制数据共享，在不建⽴直接关联的条件下，让多个不相关的进程或线程之间实现通信。

#### 尽量缓存经常使⽤的对象
> 尽可能将经常使⽤的对象进⾏缓存。
> 可以使⽤数组，或`HashMap`的容器来进⾏缓存，但这种⽅式可能导致系统占⽤过多的缓存，性能下降。
> 推荐使⽤⼀些第三⽅的开源⼯具，如EhCache，Oscache进⾏缓存，他们基本都实现了FIFO/FLU等缓存算法。

#### 使用`StringBuffer`替代字符串连接情况，减少对象创建

#### 尽量使⽤基本数据类型代替对象

```
// 这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；
String str = 'hello';

// 此时程序除创建字符串外，str所引用的String对象底层还包含一个char[]数组，这个char[]数组依次存放了h,e,l,l,o
String str = new String("hello");
```

#### 循环内尽量不要创建对象引用

```
for (int i = 1; i <= count; i++){
    Object obj = new Object();
}
// 替换为
Object obj = null;
for (int i = 0; i <= count; i++) {
    obj = new Object(); 
}
```

#### 静态类、单例类、⼯⼚类将它们的构造函数置为`private`
> 这是因为静态类、单例类、⼯⼚类这种类本来我们就不需要外部将它们`new`出来，将构造函数置为`private`之后，保证了这些类不会产⽣实例对象。

### 尽量早释放⽆⽤对象的引⽤
> ⼤部分时，⽅法局部引⽤变量所引⽤的对象会随着⽅法结束⽽变成垃圾。
> 因此，⼤部分时候程序⽆需将局部，引⽤变量显式设为`null`。
> 执行耗时任务前，可将对象引用手动设置成`null`。

### 不⽤`new`关键字创建对象的实例
> ⽤new关键词创建类的实例时，构造函数链中的所有构造函数都会被⾃动调⽤。
> 如果⼀个对象实现了Cloneable接⼝，可以调⽤它的clone()⽅法。clone()⽅法不会调⽤任何类构造函数。

### 尽量处理好包装类型和基本类型两者的使⽤场景
> 虽然包装类型和基本类型在使⽤过程中是可以相互转换，但它们两者所产⽣的内存区域是完全不同的。
> 基本类型数据产⽣和处理都在栈中处理，包装类型是对象，是在堆中产⽣实例。
> 在集合类对象，有对象⽅⾯需要的处理适⽤包装类型，其他的处理提倡使⽤基本类型。

### 尽量避免⾮常⼤的内存分配
> 分配的内存块都必须是连续的，⽽随着堆越来越满，找到较⼤的连续块越来越困难。

### 尽量不要使⽤`finalize`⽅法
> 由于GC的⼯作量很⼤，尤其是回收Young代内存时，⼤都会引起应⽤程序暂停，所以再选择使⽤`finalize`⽅法进⾏资源清理，会导致GC负担更⼤，程序运⾏效率更差。

## 容器相关

### 多线程在未发⽣线程安全前提下应尽量使⽤`HashMap`、`ArrayList`
> `HashTable`、`Vector`等使⽤了同步机制，降低了性能。

### 尽量合理的创建`HashMap`（指定容量等）
> 避免`HashMap`多次进⾏了hash重构，扩容是⼀件很耗费性能的事。在默认中`initialCapacity`只有16，⽽`loadFactor`是 0.75。

```
// 带参构造函数
public HashMap(int initialCapacity, float loadFactor);
```

### 尽量确定`StringBuffer`的容量
> `StringBuffer` 的构造器会创建⼀个默认⼤⼩（通常是16）的字符数组。
> 在使⽤中，如果超出这个⼤⼩，就会重新分配内存，创建⼀个更⼤的数组（`2*n+2`），并将原先的数组复制过来，再丢弃旧的数组。

### `ArrayList` & `LinkedList`
> 通常情况下，随机查询尽量使⽤`ArrayList`。
> 通常情况下，添加\删除的操作尽量使用`LinkedList`。

### 基于效率和类型检查，尽可能使用`array`，无法确定数组大小则使用`ArrayList`

### `HaspMap`的遍历
> 使用`entrySet()`，取得`Entry`的值后直接取key和value。

### 实现`RandomAccess`接口的集合使用`for`遍历，其他使用`foreach`
> 顺序访问，使用`foreach`遍历效率更高。其底层原理是迭代器。

### 合理使⽤`java.util.Vector`
> Vector与StringBuffer类似，每次扩展容量时，所有现有元素都要赋值到新的存储空间中。
> Vector的默认存储能⼒为10个元素，扩容加倍。

> `vector.add(index,obj)` 这个⽅法可以将元素obj插⼊到index位置，但index以及之后的元素依次都要向下移动⼀个位置（将其索
引加 1）。 除⾮必要，否则对性能不利。
> 同样规则适⽤于`remove(int index)`⽅法，移除此向量中指定位置的元素。将所有后续元素左移（将其索引减 1）。
> 所以删除vector最后⼀个元素要⽐删除第1个元素开销低很多。删除所有元素最好⽤removeAllElements()⽅法。

### 共用的集合类中不使用的数据要及时`remove`
> 如果⼀个集合类是公⽤的，那么这个集合⾥⾯的元素是不会⾃动释放的，因为始终有引⽤指向它们。
> 所以，如果公⽤集合⾥⾯的某些数据不使⽤⽽不去`remove`掉它们，那么将会造成这个公⽤集合不断增⼤，使得系统有内存泄露的隐患。

### 不要将数组声明为：`public static final`
> 因为这毫⽆意义，这样只是定义了引⽤为`static final`，数组的内容还是可以随意改变的，将数组声明为`public`更是⼀个安全漏洞，这意味着这个数组可以被外部类所改变。

### 尽量避免使⽤⼆维数组
> ⼆维数据占⽤的内存空间⽐⼀维数组多得多，⼤概10倍以上。

### 尽量使⽤`System.arraycopy ()`代替通过来循环复制数组

## 声明相关

### 考虑使⽤静态⽅法
> 如果你没有必要去访问对象的外部，那么就使你的⽅法成为静态⽅法。
> 它会被更快地调⽤，因为它不需要⼀个虚拟函数导向表。
> 这同时也是⼀个很好的实践，因为它告诉你如何区分⽅法的性质，调⽤这个⽅法不会改变对象的状态。

### 尽量避免随意使⽤静态变量
> 当某个对象被定义为`static`变量所引⽤，那么GC通常是不会回收这个对象所占有的内存。
> 如此时静态变量b的⽣命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终⽌。

```
public class A {
    private static B b = new B();
}
```

### 尽量使⽤`final`修饰符
> 带有`final`修饰符的类是不可派⽣的。
> 如果⼀个类是final的，则该类所有⽅法都是final的。java编译器会寻找机会内联（`inline`）所有的`final`⽅法（这和具体的编译器实现有关），此举能够使性能平均提⾼50%。

#### 让访问实例内变量的`getter/setter`⽅法变成`final`
> 简单的`getter/setter`⽅法应该被置成final，这会告诉编译器，这个⽅法不会被重载，所以，可以变成`inlined`。

### 尽量使⽤局部变量
> 调⽤⽅法时传递的参数以及在调⽤中创建的临时变量都保存在栈（`Stack`）中，速度较快；
> 其他变量，如静态变量、实例变量等，都在堆（`Heap`）中创建，速度较慢。

### 不要重复初始化变量
> 默认情况下，调⽤类的构造函数时，java会把变量初始化成确定的值。
> 注意当⼀个类从另⼀个类派⽣时，⽤`new`关键字创建⼀个对象，构造函数链中的所有构造函数都会被⾃动调⽤。
> 给成员变量设置初始值但需要调⽤其他⽅法的时候，最好放在⼀个⽅法。因为直接调⽤某⽅法赋值可能会因为类尚未初始化⽽抛空指针异常。

|变量|默认初始值|
|---|---|
|对象|`null`
|整数|0
|`float`和`double`|`0.0`
|布尔|`false`

### 不要在`public`方法中添加太多形参

1. 违反了⾯向对象的编程思想
1. 参数太多势必导致⽅法调⽤的出错概率增加

## 线程相关

### 使用线程池
> 可以避免频繁地创建和销毁线程。

### 慎⽤`synchronized`，尽量减⼩`synchronized`的⽅法
> 实现同步是要很⼤的系统开销作为代价的，甚⾄可能造成死锁，所以尽量避免⽆谓的同步控制。
> `synchronized`⽅法被调⽤时，直接会把当前对象锁了，在⽅法执⾏完之前其他线程⽆法调⽤当前对象的其他⽅法。
> 应尽量使⽤**⽅法同步代替代码块同步**。

### 避免`Random`实例被多线程使用
> 竞争`seed`会导致性能下降。可以使用`ThreadLocalRandom`获取随机数。

### 对于`ThreadLocal`使⽤前后⼀定要先`remove`
> `Thread`类中，持有`ThreadLocal.ThreadLocalMap`的引⽤。
> 使用线程池，线程不会被销毁。线程不销毁意味着上条线程`ThreadLocal.ThreadLocalMap`中的数据依然存在，那么在下⼀条线程重⽤这个Thread的时候，很可能get到的是上条线程set的数据⽽不是⾃⼰想要的内容。

## IO相关

### 使用数据库连接池
> 可以避免频繁打开和关闭连接

### 及时关闭IO流，释放资源
> 在java编程过程中，进⾏数据库连接，I/O流操作，在使⽤完毕后，及时关闭以释放资源。
> 因为对这些⼤对象的操作会造成系统⼤的开销。

#### 尽量在`finally`块中释放资源
> 程序中使⽤到的资源应当被释放，以避免资源泄漏，这最好在`finally`块中去做。
> 不管程序执⾏的结果如何，`finally`块总是会执⾏的，以确保资源的正确关闭。

### 使用带缓冲的输入输出流操作IO
> 带缓冲的输入输出流，可以极大提升IO效率。

## 异常相关

### 慎⽤异常
> 当创建⼀个异常时，需要收集⼀个栈跟踪(`stack track`)，这个栈跟踪⽤于描述异常是在何处创建的。
> 构建这些栈跟踪时需要为运⾏时栈做⼀份快照，会暂时停⽌⼊栈和出栈操作，正是这⼀部分开销很⼤。
> 所以，栈跟踪不只包含运⾏时栈中的⼀两个元素，⽽是包含这个栈中的每⼀个元素。

> 异常是为异常的情况⽽设计的，使⽤时也应该牢记这⼀原则。

### 不要在循环中使⽤`Try/Catch`语句，应把`Try/Catch`放在循环最外层
> `Error`是获取系统错误的类，或者说是虚拟机错误的类。
> 不是所有的错误`Exception`都能获取到的。虚拟机报错`Exception`就获取不到，必须⽤`Error`获取。

## 其他

### 尽量减少对变量的重复计算
> 在循环中应该避免使⽤复杂的表达式。
> 在循环中，循环条件会被反复计算，如果不使⽤复杂表达式，⽽使循环条件值不变的话，程序将会运⾏的更快。

### 尽量使⽤移位来代替`a/b`、`a*b`的操作
> 使⽤移位的操作将更快和更有效。使用位移操作应添加注释，加强理解。

### 尽量避免使⽤`split`
> 除⾮是必须的，否则应该避免使⽤`split`。
> `split`由于⽀持正则表达式，所以效率⽐较低，如果是频繁的⼏⼗，⼏百万的调⽤将会耗费⼤量资源。
> 可以考虑使⽤apache的`StringUtils.split(string,char)`，频繁`split`的可以缓存结果。

### 在字符串相加的时候，如果该字符串只有⼀个字符的话，使用`''`代替`""`

```
String str = "a" + "b";
// 替换成
String str = 'a' + 'b';
```

### 避免程序运行过程中使用反射
> 尤其是`Method`中`invoke`方法。如必须使用，建议在启动中进行，将反射实例化出的对象放入内存。

### 基本数据类型转换为字符串
> 效率依次为：

1. `v.toString()`
2. `String.valueOf(v)`
3. `v + ""`