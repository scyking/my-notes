# linux 文件描述符

标签（空格分隔）： linux

---

[toc]

## 概念
> Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符(`fd`)，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。

## 与文件和进程间的关系

### 描述

- 每个文件描述符会与一个打开的文件相对应
- 不同的文件描述符也可能指向同一个文件
- 相同的文件可以被不同的进程打开，也可以在同一个进程被多次打开

### 相关表
> 系统为维护文件描述符建立。

|表名|记录内容|
|---|---|
|进程级的文件描述符表|1\. 文件描述标志<br>2. 文件指针（open file handle） 
|系统级的文件描述符表<br>（open file table）|1\. 当前文件偏移量<br>2. 状态标识<br>3. 文件访问模式（读、写、读写）<br>4. 对该文件i-node对象的引用<br>5. 文件类型（常规文件、套接字、FIFO...）<br>6. 访问权限<br>7. 一个指向该文件所持有的所累表的指针<br>8. 文件的各种属性<br>9. 与信号驱动相关的设置
|文件系统的`i-node`表|1\. 文件类型<br>2. 文件锁

### 文件描述符使用

![文件描述符](https://image-static.segmentfault.com/297/402/2974023913-593aafdfac773_fix732)

- 在进程A中，文件描述符`1`和`30`都指向了同一个打开的文件句柄（`#23`），这可能是该进程多次对执行打开操作

- 进程A中的文件描述符`2`和进程B的文件描述符`2`都指向了同一个打开的文件句柄（`#73`），这种情况有几种可能：
    1. 进程A和进程B可能是父子进程关系;
    2. 进程A和进程B打开了同一个文件，且文件描述符相同；
    3. A、B中某个进程通过UNIX域套接字将一个打开的文件描述符传递给另一个进程。

- 进程A的描述符`0`和进程B的描述符`3`分别指向不同的打开文件句柄，但这些句柄均指向i-node表的相同条目（`#1936`），换言之，指向同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了打开请求。同一个进程两次打开同一个文件，也会发生类似情况。

## 文件描述符类型

|类型	|文件描述符	|重定向符号	|位置
|---|---|---|---|
|标准输入（stdin）	|0	|`0<`或`0<<`	|`/dev/stdin -> /proc/self/fd/0`
|标准输出（stdout）	|1	|`1>`或`1>>`	|`/dev/stdout -> /proc/self/fd/1`
|错误输出（stderr）	|2	|`2>`或`2>>`	|`/dev/stderr -> /proc/self/fd/2`

- 标准输入重定向`0<`或`0<<`等同于`<`或`<<`，使用时一般省略`0`
- 标准输出重定向`1>`或`1>>`等同于`>`或`>>`，使用时一般省略`1`

### 重定向操作

#### 重定向到文件中

- 输出重定向

    1. 覆盖：`cmd n> file`
    1. 追加：`cmd n>> file`
    1. 标准错误与标准输出同时重定向：`cmd &> file`

- 输入重定向

    1. 普通重定向：cmd < file
    1. here documents：
    
        ```
        cmd << delimiter
        …
        delimiter
        ```

#### 重定向到另一个文件描述符中

1. n的输出重定向到m中：`cmd n>&m`

#### exec分配文件描述符

1. 以读写的方式打开文件，并分配文件描述符： `exec n<> file (exec n< file / exec n> file)`
1. 关闭文件描述符：`exec n>&-`
1. 创建文件描述符的副本：`exec n>&m`

### `>/dev/null 2>&1`
> 表示将标准输出及错误输出全部重定向到“黑洞”，这么做可以有效的防止结果输出到控制台，以及inode节点被写满。

- `>/dev/null`将标准输出重定向到空设备，即“黑洞”
- `2>&1` 表示错误输出重定向等同于标准输出
    - `2>`表示错误输出
    - `&`表示等同的意思
    - `1`标准输出




