# 常见数据结构

标签（空格分隔）： 数据结构

---

[toc]

## 队列（queue）
> 一种**先进先出（FIFO）**线性表，允许在表头删除元素，在表尾插入元素。

- java中`Queue`基本方法：
    1. 入队：`add`/`offer`
    1. 出队：`remove`/`poll`
    1. 获取队头元素（不删除）：`element`/`peek`

## 栈（stack）
> 一种**先进后出（FILO）**线性表，允许在栈顶插入/删除元素。

- java中`Stack`基本方法：
    1. 入栈：`push`
    1. 出栈：`pop`
    1. 获取栈顶元素（不删除）：`peek`

## 堆（heap）
> 用数组实现的二叉树。根据**堆属性**来排序，**堆属性**决定了树中节点的位置。

### 常用方法

- 构建优先队列
- 支持堆排序
- 快速找出一个集合中的最小值（或者最大值）

### 堆属性

- 最大堆：父节点的值比每一个子节点的值都要大
- 最小堆：父节点的值比每一个子节点的值都要小

### 与其他树区别

1. 节点的顺序
    > 在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。

1. 内存占用
    > 普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配内存。堆仅仅使用一个数据来存储数组，且不使用指针。

1. 平衡
    > 二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(log n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足堆属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(log n) 的性能。

1. 搜索
    > 在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。