# Redis 缓存数据一致性

标签（空格分隔）： redis

---

[toc]

## 问题描述

> 当DB数据更新时，缓存中的数据会与DB数据不一致，这时需要更新缓存数据或者淘汰缓存。

## 解决方法

### 先更新数据库，再更新缓存

存在问题：

1. 由于网络等原因，导致缓存的数据是旧数据。更新数据库次序与更新缓存不一致，导致数据不一致。
1. 如果缓存的数据是经过各种复杂计算后写入的，那每次写入缓存都要运算一次，此法不可取。
1. 写场景多而读场景少的业务需求，此时缓存不是经常性的读，却被频繁的更新。

### 先删缓存，再更新数据库

存在问题：

> 缓存被删除，数据库没有更新完成期间，有查询请求进来，导致缓存中出现脏数据。

解决办法：
> 采用延时双删策略解决，即删除缓存->更新数据库->延时等待->删除缓存

延时双删问题：

1. 二次删除前面涉及到休眠，可能导致系统性能降低，可以采用异步的方式，再起一个线程来进行异步删除。
2. 如果二次删除失败了，还是会导致缓存脏数据存在。

### 先更新数据库，再删缓存
> 相比先删除缓存，再更新数据稳妥些。

存在问题：

> 如果删除缓存失败了，仍会导致缓存跟数据不一致。

#### 最终一致性方案
> 通过消息队列，确保删除缓存

1. 更新数据库
2. 删除缓存
3. 如果删除缓存失败，将消息发送到MQ中，不断消费重试

存在问题：

1. 对业务线代码造成大量的侵入，引入了中间件。
1. 消息的延迟删除也会造成短暂的不一致。

解决方法：

订阅数据库`binlog`（mysql可使用`canal`），根据订阅消息，操作缓存数据库。

## 总结

> 数据更新时，缓存是删除不是更新。

删除缓存方法：

1. 如果缓存数据不敏感，直接给缓存设置TTL即可。
1. 先删缓存再更新数据库，此时需配合延时双删技术，但可能导致二次删除失败。
1. 先更新数据库再删缓存，此时需配合binlog消费 + 消息队列来实现。