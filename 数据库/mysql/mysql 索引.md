# mysql 索引

标签（空格分隔）： mysql

---

[toc]

## 操作索引 SQL

- 显示索引信息

```
show index from <table-name>
```

- 创建索引

```
-- unique 表示唯一
-- 列可以是多个，多个即组合索引
create [unique] index <index-name> on <table-name> (<column-name>)
```

- 修改表（添加索引）

```
alter table <table-name> add [unique] index <index-name> (<column-name>)
```

- 创建表（添加索引）

```
create table <table-name> (
    
    id int not null,
    
    username varchar(16) not null,
    
    [unique] index [<index-name>](username(<length>))

);
```

- 删除索引

```
drop index [<index-name>] on <table-name>
```

- 修改表（删除索引）

```
alter table <table-name> drop index <index-name>
```

## 索引分类

### 按存储结构划分

- 哈希索引
- 二叉树索引
- B树索引
- 跳表

### 按应用层次划分

- 普通索引：即⼀个索引只包含单个列，⼀个表可以有多个单列索引
- 唯⼀索引：索引列的值必须唯⼀，但允许有空值
- 组合索引：即⼀个索引包含多个列
- 组合唯一索引：即列值组合必须唯一
- 主键索引：特殊的唯一索引，不允许有空值
- 全文索引（mysql 5.6版本以后支持）

### 按索引指向划分
> 非主键索引，即二级索引（辅助索引、次索引）。

- 聚簇索引：二级索引指向对主键索引的引用。（Innodb）
- 非聚簇索引：二级索引和主键索引都指向物理行。（MyISAM）

## InnoDB 索引结构
> 使用B+树实现索引结构。
> 对于频繁访问的表，InnoDB 会透明建立自适应Hash索引（在B+树索引基础上建立Hash索引），提高查找效率。

### 使用B+树结构原因
> 数据库的索引是存储在磁盘上的。当数据量很大的时候，不能把整个索引加载到内存中，只能逐一加载每个磁盘页（对应树的结点）。
> 所以，IO次数就是树的高度。

- Hash，可快速定位，但没有顺序，IO复杂度高。只适合等值查询，不适合范围查询。
- 二叉树，树的高度不均匀，不能自平衡，查找效率和数据有关。
- 红黑树，数的高度随数据量增加而增加，IO代价高。
- B树，不适合范围查询。范围查询，每个结果都需要重新检索。

### 建议使用自增主键原因
> 自增主键是连续的，在插入B+树过程中会减少分裂和数据移动次数。

### 可存储数据量
> 约2千万行。

- 在计算机中，磁盘存储数据最小单元是扇区，一个扇区的大小是512字节
- 文件系统中，最小单位是块，一个块大小就是4k
- InnoDB最小储存单元是页，一页大小就是16k

分析过程：

1. B+树中，叶子结点存储数据、非叶子结点存储`键值+指针`
2. 假设B+树高度是2。存储数据量=根节点指针树*单个叶子结点记录行数
3. 如果一行记录的数据大小为1k，那么单个叶子节点记录行数=16k/1k=16
4. 假设主键id为bigint类型（`8 byte`），指针大小在Innodb中设置为`6 byte`。非叶子结点存储指针数=16k/(8+6)b=16*1024b/14b≈1170
5. 一棵高度为2的B+树，能存放数据量=1170*16=18720条
6. 同理一棵高度为3的B+树，能存放数据量=1170*1170*16=21902400。B+树高度一般为1-3层，已经满足千万级别的数据存储。

## 索引优化
1. 分⻚查询很重要，如果查询数据量超过30%，MYSQL不会使⽤索引。
2. 单表索引数不超过5个、单个索引字段数不超过5个。
3. 字符串可使⽤前缀索引，前缀⻓度控制在5-8个字符。
4. 选择字段唯⼀性太低，增加索引没有意义，如：是否删除、性别。
5. 合理使⽤覆盖索引、索引下推、最左匹配。
6. 不要对索引进行函数操作。注意隐式的类型转换和字符编码转换。
7. 仅可能扩展索引，不要新建立索引。

### 适合创建索引场景

- 频繁作为查询条件的字段应创建索引
- 多表关联查询的时候，关联字段应该创建索引
- 查询中的排序字段，应该创建索引
- 统计或者分组字段需要创建索引

### 不适合创建索引场景
- 表记录少
- 经常增删改查的表
- 频繁更新的字段
- where 条件使⽤不⾼的字段
- 字段很⼤的时候

## 优化相关概念

### 索引维护
> 索引是需要占⽤空间的，索引虽能提升查询速度但是也不能滥⽤。

> B+树在维护索引有序性时，进行删除、插入结点时会进行必要的维护。

> 在 Innodb 中删除结点，会将结点标记位“可复用”以减少对结构变动。

> 增加结点时，如果数据页已满，会进行页的分裂。页的分裂比较耗时，并且会降低页的利用率。

### 回表查询
> 在辅助索引上找到对应的主键值并通过主键值在聚簇索引上查询到对应数据，这个过程就是回表。

```
-- 假如已在test表age字段建立索引。该查询先通过索引查询到主键值位置，再通过聚簇索引查询到对应行记录。
select name from test where age=18
```

### 覆盖索引
> 使用辅助索引时，已经可以获取到需要查的数据。 InnoDB 会进⾏ **覆盖索引** ，减少回表而提升效率。

```
-- 使用辅助索引，已经能够获取到所需数据，不需要进行回表操作，这就是覆盖索引。
select id from test where age = 18;
```

#### 组合索引
> 通过辅助索引可以直接获取到所需数据，不需要回表，提升检索效率。

```
-- 假如已有组合索引 index(class,name) 
-- 该查询可以通过辅助索引直接获取到name信息，则不需要进行回表
select name from stu where class = 102;
```

#### **最左前缀原则**
> ⼀种联合索引的匹配规则。
> 假如索引是`index(a,b,c)`，则支持`a|a,b|a,b,c|`查找，不支持`b|b,c|c`查找。
> 使用范围匹配，索引会失效。

#### 索引下推（mysql 5.6以后版本支持）
> Index Condition Pushdown （ICP），在组合索引上的优化，减少回表次数。

## 索引失效场景
> 使用分析命令`explain`。如果`key`对应结果为`NULL`，说明没有使用索引。

### 列与列对比
> 假如test表中id、cid都单独建立了索引。

```
-- 这种查询条件不会走索引，会全表扫描
select * from test where id=cid;
```

### 存在`NULL`值条件
> 索引可能失效。
> 具体依据读取二级索引记录成本。扫描的二级索引记录越多，需要执行的回标操作也越多，达到一定比例，会进行全表扫描。

### 使用`OR`查询条件
> 索引生效，需要`OR`中每列上都有索引。

### 查询条件为非时，包括`<>`、`NOT`、`IN`、`NOT EXISTS`
> 建立索引时，会给每一个索引建立一个条目。如果查询条件为等值或范围查询时，索引可以根据查询条件去找对应条目。

```
-- 不会索引
select * from test where age<>18;
-- 可以索引
select * from test where age>18 or age<18
```

### `LIKE`通配符
> 使用后置统通配符，会走索引。使用前置统通配符，会全表扫描。

```
-- 后置通配符
select * from test where name like 张||'%';
-- 前置统配符
select * from test where name like '%'||三;
```

### 条件上包含函数

```
-- 对索引列使用函数，不会索引。因为索引经过函数计算后可能与创建时不同，而无法定位。
select * from test where upper(name)='SCYKING';
-- 可以索引
select * from test where name=upper('scyking');
-- 同理，使用谓词运算，同样会失效
select * from test where age/2=12;
-- 可以索引
select * from test where age=12*2;
```

### 不符合组合索引最左前缀匹配原则
> 假如索引是`index(a,b,c)`，则支持`a|a,b|a,b,c|`查找，不支持`b,c|c`查找。

### 组合索引前导列区分大
> 当复合索引前导列区分小的时候，有`INDEX SKIP SCAN`。
> 当前导列区分度大，且查后导列的时候，前导列的分裂会非常耗资源，执行计划，不如全表扫描来快，导致索引失效。

### **数据类型的转换**
> 当当查询条件存在隐式转换时，索引会失效。

```
-- 假如id是number类型，此时索引失效
select * from test where id='123'
```

### 使用层级查询